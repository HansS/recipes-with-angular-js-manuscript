# Directives
Directives are one of the most powerful concepts in Angular since they let you invent new html syntax specific to your application. This allows you to create reusable components which encapsulate complex DOM structures, stylesheets and even behaviour. 

## Enable/Disable DOM element conditionally

### Problem
You want to disable a button depending on a checkbox state.

### Solution
Use the `ng-disabled` directive and bind its condition to the checkbox state.

    <body ng-app>
      <label><input type="checkbox" ng-model="checked"/>Toggle Button</label>
      <button ng-disabled="checked">Press me</button>
    </body>

### Discussion
The `ng-disabled` directive is a direct translation from the disabled HTML attribute, without you needing to worry about browser incompatibilities. It is bound to the `checked` model using an attribute value as is the checkbox using the `ng-model` directive. In fact the `checked` attribute value is again an Angular expression. You could for example invert the logic and use `!checked` instead.

This is just one example of a directive shipped with Angular. There are many others as for example `ng-hide`, `ng-checked` or `ng-mouseenter` and I encourage you go through the [API Reference](http://docs.angularjs.org/api) and explore all the directives Angular has to offer. 

In the next recipes we will focus on implementing directives.

## Implement DOM changes in response to user behaviour

### Problem
You want to change the css of an HTML element on a mouse click and encapsulate this behaviour in a reusable component.

### Solution
Implement a directive with defines a link function.

    <body ng-app="MyApp">
      <my-widget>
        <p>Hello World</p>
      </my-widget>
    </body>


    var app = angular.module("MyApp", []);

    app.directive("myWidget", function() {
      var linkFunction = function(scope, element, attributes) {
        var paragraph = element.children()[0];
        $(paragraph).on("click", function() {
          $(this).css({ "background-color": "red" });
        });
      };

      return {
        restrict: "E",
        link: linkFunction
      };
    });

When clicking on the paragraph the background color changes to red.

### Discussion
In the HTML document we use the new directive as an HTML element `my-widget`, which can be found in the javascript code as `myWidget` again. The directive function returns a restriction and a link function. 

The restriction means that this directive can only be used as an HTML element and not for example an HTML attribute. If you want to use it as an HTML attribute, change the `restrict` to return `A` instead. The usage would then have to be adapted to:

    <div my-widget>
      <p>Hello World</p>
    </div>

Wether you use the attribute or element mechanism depends on your use case. Generally speaking one would use the element mechanism to define a custom reusable component. The attribute mechanism would be used whenever you want to "configure" some element or enhance it with more behaviour. Other options are using the directive as a class attribute or a comment. 

The link function is much more interesting since it defines the actual behaviour. The scope, the actual HTML element `my-widget` and the html attributes are passed as params. Note, that this has nothing to do with Angulars dependency injection mechanism. Ordering of the parameters is important!

First we select the paragraph element, which is a child of the `my-widget` element using Angulars `children()` function as defined by element. In the second step we use jQuery to bind to the click event and modify the css property on click. This is of special interest since we have a mixture of Angular element functions and jQuery here. In fact under the hood Angular will use jQuery in the `children()` function if its defined and will fall back to jqLite (shipped with Angular) otherwise. You can find all supported methods in the [API Reference of element](http://docs.angularjs.org/api/angular.element).

Following a slightly changed version of the code using jQuery only:

    element.on("click", function() {
      $(this).css({ "background-color": "red" });
    });

In this case `element` is alreay an jQuery element and we can directly use the on function.

## Render an html snippet

### Problem
You want to render a html snippet in multiple places

### Solution
Implement a directive and use the template attribute to define the HTML.

    <body ng-app="MyApp">
      <my-widget/>
    </body>

    var app = angular.module("MyApp", []);

    app.directive("myWidget", function() {
      return {
        restrict: "E",
        template: "<p>Hello World</p>"
      };
    });

### Discussion
This will render the Hello World paragraph as a child node of your `my-widget` element. In case you want to replace the element entirely with the paragraph you have to additionally return the replace attribute:

    app.directive("myWidget", function() {
      return {
        restrict: "E",
        replace: true,
        template: "<p>Hello World</p>"
      };
    });

Another option would be to use a file for the HTML snippet. In this case you need to use the templateUrl attribute, as for example:
  
    app.directive("myWidget", function() {
      return {
        restrict: "E",
        replace: true,
        templateUrl: "widget.html"
      };
    });

The `widget.html` should reside in the same directory as the `index.html` file. This will only work if you use a web server to host the file. The example on Github uses angular-seed as bootstrap again.

## Use directives child nodes in directive output

### Problem
Your widget uses the child nodes of the directive element to create a combined rendering.

### Solution
Use the `transclude` attribute together with the `ng-transclude` directive.

    <my-widget>
      <p>This is my paragraph text.</p>
    </my-widget>

    var app = angular.module("MyApp", []);

    app.directive("myWidget", function() {
      return {
        restrict: "E",
        transclude: true,
        template: "<div ng-transclude><h3>Heading</h3></div>"
      };
    });

This will render a `div` element containing a `h3` element and append the directives child node with the paragraph element below.

### Discussion 
In this context transclusion refers to the inclusion of a part of a document into another document by reference. The `ng-transclude` attribute should be placed depending on where you want your child nodes to be appended to.

## Pass configuration params using HTML attributes

### Problem
You want to pass a configuration param to change the rendered output.

### Solution
Use the attribute based directive and pass an attribute value for the configuration. The attribute is passed as a parameter to the link function.

    <body ng-app="MyApp">
      <div my-widget="Hello World"></div>
    </body>

    var app = angular.module("MyApp", []);

    app.directive("myWidget", function() {
      var linkFunction = function(scope, element, attributes) {
        scope.text = attributes["myWidget"];
      };

      return {
        restrict: "A",
        template: "<p>{{text}}</div>",
        link: linkFunction
      };
    });


### Discussion
The link function has access to the element and its attributes. It is therefore straight forward to set the scope to the text passed as the attributes value and use this in the template evaluation.

The scope context is important though. The `text` scope we changed might have changed and existing model used in another place of your app. In order to isolate the context and thereby using it only locally inside of your directive we have to return an additional scope attribute.

    return {
      restrict: "A",
      template: "<p>{{text}}</div>",
      link: linkFunction,
      scope: {}
    };

## Render an HTML snippet repeatedly

### Problem
You want to render an html snippet repeatedly using the directives child nodes as the "stamp" content.

### Solution
Implement a compile function in your directive.
    
    <repeat-ntimes repeat="10">
      <h1>Header 1</h1>
      <p>This is the paragraph.</p>
    </repeat-n-times>

    var app = angular.module("MyApp", []);

    app.directive("repeatNtimes", function() {
      return {
        restrict: "E",
        compile: function(tElement, attrs) {
          var content = tElement.children();
          for (var i=1; i<attrs.repeat; i++) {
            tElement.append(content.clone());
          }
        }
      };
    });

This will render the header and paragraph 10 times.

### Discussion
The directive repeats the child nodes as often as configured in the `repeat` attribute. It works similarly to the [ng-repeat](http://docs.angularjs.org/api/ng.directive:ngRepeat) directive. The implemention uses Angulars element methods to append the child nodes in a for loop.

Note, that the compile method only has access to the templates element (tElement) and template attributes. It has no access to the scope and you therefore also can't use `$watch` to add behaviour. This is in comparison to the link function which has access to the DOM "instance" (after the compile phase) and has access to the scope to add behaviour.

Use the compile function for template DOM manipulation only. Use the link function when you want to add behaviour.

Note, that you can use both compile and link function combined. In this case the compile function must return the link function. As an example you want to react to a click on the header:

    compile: function(tElement, attrs) {
      var content = tElement.children();
      for (var i=1; i<attrs.repeat; i++) {
        tElement.append(content.clone());
      }

      return function (scope, element, attrs) {
        element.on("click", "h1", function() {
          $(this).css({ "background-color": "red" });
        });
      };
    }


## Testing directives

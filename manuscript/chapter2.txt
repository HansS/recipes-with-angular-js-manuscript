# Controllers
Controllers in Angular handle view behaviour, for example the user clicking a button or entering some text in a form. What should happen next is implemented in a Controller. As a general rule a Controller should not reference the DOM directly. This dramatically simplifies unit testing Controllers.

## Assigning a Default Value to a Model

### Problem
You want to assign a default value to the scope in the controllers context.

### Solution

    <div ng-controller="MyCtrl">
      <p>{{value}}</p>
    </div>

    var MyCtrl = function($scope) {
      $scope.value = "some value";
    };

### Discussion
Depending on where you use the ng-controller directive, you define its assigned scope. The scope is hierachical and follows the DOM nodes hierarchy. In our example the value expression is correctly evaluated to `some value`, since value is set in the `MyCtrl` controller. Note, that this would not work if the value expression is moved outside the controllers scope:

    <p>{{value}}</p>

    <div ng-controller="MyCtrl">
    </div>

In this case `{{value}}` will simply be not rendered at all.

## Changing a Model Value with a Controller Function

### Problem
You want to increment a model value by 1.

### Solution
Implement an increment function which changes the scope.

    <div ng-controller="MyCtrl">
      <p ng-init="incrementValue(5)">{{value}}</p>
    </div>

    function MyCtrl($scope) {
      $scope.value = 1;

      $scope.incrementValue = function(value) {
        $scope.value += 1;
      };
    }

### Discussion
The `ng-init` directive is executed on page load and calls the function defined in `MyCtrl`.

## Encapsulating a Model Value with a Controller Function

### Problem
You want to retrieve a model via function (instead of directly accessing the scope from the template) which further changes the model value.

### Solution
Define a getter function which returns the model value.

    <div ng-controller="MyCtrl">
      <p>{{getIncrementedValue()}}</p>
    </div>

    function MyCtrl($scope) {
      $scope.value = 1;

      $scope.getIncrementedValue = function() {
        return $scope.value + 1;
      };
    }

### Discussion
`MyCtrl` defines the `getIncrementedValue` function which uses the current value and returns it incremented by one. One could argue that depending on the use case it would make more sense to use a filter. But, there are use cases specific to the controllers behaviour which you might not want to use a generic directive.

## Responding to Scope Changes

### Problem
You want to react on a model change to trigger some further actions. In our example we simple want to set another model value depending on the value we are listing on.

### Solution
Use the `$watch` function in your controller.

    <div ng-controller="MyCtrl">
      <input type="text" ng-model="name" placeholder="Enter your name">
      <p>{{greeting}}</p>
    </div>

    function MyCtrl($scope) {
      $scope.name = "";

      $scope.$watch("name", function(newValue, oldValue) {
        if ($scope.name.length > 0) {
          $scope.greeting = "Greetings " + $scope.name;
        }
      });
    }

The value `greeting` will be changed whenever there's a change on the `name` model and the value is not blank.

### Discussion
The first argument `name` of the `$watch` function is actually an Angular expression, so you can use more complicated expressions (for example: `[value1, value2] | json`). Alternatively, you can also use a javascript function:

    $scope.$watch(function() {
      return $scope.name;
    }, function(newValue, oldValue) {
      console.log("change detected: " + newValue)
    });

Note, that you need to return a String in the watcher function. The second function will only be called if the returned String changed compared to the previous execution. Internally this uses `angular.equals` to determine equality.

## Sharing Models Between Nested Controllers

### Problem
You want to share a model between a nested hierarchy of controllers.

### Solution
Use javascript objects instead of primitives or direct `$parent` references.

The example template uses a controller and a nested controller `MyNestedCtrl`:

    <body ng-app="MyApp">
      <div ng-controller="MyCtrl">
        <label>Primitive</label>
        <input type="text" ng-model="name">

        <label>Object</label>
        <input type="text" ng-model="user.name">

        <div class="nested" ng-controller="MyNestedCtrl">
          <label>Primitive</label>
          <input type="text" ng-model="name">

          <label>Primitive with explicit $parent reference</label>
          <input type="text" ng-model="$parent.name">

          <label>Object</label>
          <input type="text" ng-model="user.name">
        </div>
      </div>
    </body>

The `app.js` file contains the controller definition and initializes the scope with some defaults:

    var app = angular.module("MyApp", []);

    app.controller("MyCtrl", function($scope) {
      $scope.name = "Peter";
      $scope.user = {
        name: "Parker"
      };
    });

    app.controller("MyNestedCtrl", function($scope) {
    });

Play around with the various input fields and check how changes affect each other.

### Discussion
All the default values are defined in `MyCtrl` which is the parent of `MyNestedCtrl`. When doing changes in the first input field, the changes will be in sync with the other input fields bound to the `name` variable. They all share the same scope variable as long as they only read from the variable. If you change the nested value, a copy in the scope of the `MyNestedCtrl` will be created. From now on, changing the first input field will only change the nested input field which explicitly references the parent scope via `$parent.name` expression.

The object based value behaves differently in this regard. Wether you change the nested or the `MyCtrl` scopes input fields, the changes will stay in sync. In Angular a scope prototypically inherits properties from a parent scope. Objects are therefore references and kept in sync. Whereas primitive types are only in sync as long they are not changed in the child scope.

Generally I tend to not use `$parent.name` and instead always use objects to share model properties. Additionally, the `MyNestedCtrl` not only requires certain model attributes but also a correct scope hierachy to work with.

## Sharing Code Between Controllers using Services

### Problem
You want to share business logic between controllers.

### Solution
Use a [Service](http://docs.angularjs.org/guide/dev_guide.services) to implement your business logic and use dependency injection to use this service in your controllers.

The template shows access to a list of users from two controllers:

    <div ng-controller="MyCtrl">
      <ul ng-repeat="user in users">
        <li>{{user}}</li>
      </ul>
      <div class="nested" ng-controller="AnotherCtrl">
        First user: {{firstUser}}
      </div>
    </div>

The service and controller implementation in `app.js` implements a user service and the controllers set the scope initially:

    var app = angular.module("MyApp", []);

    app.factory("UserService", function() {
      var users = ["Peter", "Daniel", "Nina"];

      return {
        all: function() {
          return users;
        },
        first: function() {
          return users[0];
        }
      };
    });

    app.controller("MyCtrl", function($scope, UserService) {
      $scope.users = UserService.all();
    });

    app.controller("AnotherCtrl", function($scope, UserService) {
      $scope.firstUser = UserService.first();
    });

### Discussion
The `factory` method creates a singleton `UserService` which returns two functions for retrieving all users and the first user only. The controllers get the `UserService` injected by adding it to the function as params.

## Testing Controllers

### Problem
You want to unit test your business logic.

### Solution
Implement a unit test using [Jasmine](http://pivotal.github.com/jasmine/) and the [angular-seed](https://github.com/angular/angular-seed) project. Following our previous `$watch` recipe this is how our spec would look like.

    describe('MyCtrl', function(){
      var scope, ctrl;

      beforeEach(inject(function($injector, $controller, $rootScope) {
        scope = $rootScope.$new();
        ctrl = $controller(MyCtrl, { $scope: scope });
      }));

      it('should change greeting value if name value is changed', function() {
        scope.name = "Frederik";
        scope.$digest();
        expect(scope.greeting).toBe("Greetings Frederik");
      });
    });


### Discussion
Jasmine specs use `describe` and `it` functions to group specs and `beforeEach` and `afterEach` to setup and teardown code. The actual expectation compares the greeting from the scope with our expectation `Greetings Frederik`.

The scope and controller initialization is a bit more involved. We use `inject` to initialize the scope and controller as closely as possible to how our code would behave at runtime too. We can't just initialize the scope as an javascript object `{}` since then we would not be able to call `$watch` on it.

The `$digest` call is required in order for another watch execution. We need to call `$digest` manually in our spec whereas at runtime Angular will do this for us automatically.


# Consuming Externals Services
Angular has built-in support for doing AJAX requests with low- and high-level APIs.

## Requesting JSON Data with AJAX

### Problem
You want to do an AJAX request to fetch JSON data and render it.

### Solution
Implement a controller using `$http` to fetch the data and store it in the scope.

    <body ng-app="MyApp">
      <div ng-controller="PostsCtrl">
        <ul ng-repeat="post in posts">
          <li>{{post.title}}</li>
        </ul>
      </div>
    </body>

    var app = angular.module("MyApp", []);

    app.controller("PostsCtrl", function($scope, $http) {
      $http.get('data/posts.json').
        success(function(data, status, headers, config) {
          $scope.posts = data;
        });
    });

### Discussion
The controller defines a dependency to the `$scope` and the `$http` module. An HTTP get call to the `data/posts.json` URL is done and on success the JSON data is put in `$scope.posts`.

You can set custom HTTP headers by using the `$http.defaults` function:

    $http.defaults.headers.common["X-Custom-Header"] = "Angular.js"

The complete example uses the angular-seed project again.

## Consuming RESTful APIs

### Problem
You want to consume a RESTful API.

### Solution
Use Angular's high-level `$resource` module to use RESTful APIs.

Let us start with defining the application module and our `Post` model:

    var app = angular.module('myApp', ['ngResource']);

    app.factory("Post", function($resource) {
      return $resource("/api/posts/:id");
    });

Now we can use the `$resource$ to retrieve a list of posts:

    app.controller("PostIndexCtrl", function($scope, Post) {
      Post.query(function(data) {
        $scope.posts = data;
      });
    });

Or a specific post by `id`:

    app.controller("PostShowCtrl", function($scope, Post) {
      Post.get({ id: 1 }, function(data) {
        $scope.post = data;
      });
    });

And delete a specific post:

    app.controller("PostDestroyCtrl", function($scope, Post) {
      $scope.destroy = function(id) {
        Post.delete({ id: id });
      }
    });

Note, that the Angular `ngResource` module needs to be separately loaded since it is not included in the base angular.js file:

    <script src="angular-resource.js">

### Discussion
Following some conventions simplifies our code quite a bit. We define the `$resource` by passing the URL schema only. This gives us a handful of nice methods including query, get, save and remove to work with our resource. In the example above we implement several controllers to cover the various typical use cases.

It is generally a good practice to encapsulate your model and `$resource$` usage in an Angular `service` module and inject that in your controller.

What if your response of posts is not an array but a more complex json? This typically results in the following error:

    TypeError: Object #<Resource> has no method 'push'

Have a look at the following JSON example:

    {
      "posts": [
        {
          "id"    : 1,
          "title" : "title 1"
        },
        {
          "id": 2,
          "title" : "title 2"
        }
      ]
    }

In this case you have to change the `$resource$ definition accordingly.

    app.factory("Post", function($resource) {
      return $resource("/api/posts/:id", {}, {
        query: { method: "GET", isArray: false }
      });
    });

    app.controller("PostIndexCtrl", function($scope, Post) {
      Post.query(function(data) {
        $scope.posts = data.posts;
      });
    });

Note, that we only change the configuration of the `query` action to not expecting an array. Then in our controller we can directly access the `data.posts`.

The complete example code is based on Brian Ford's [angular-express-seed](https://github.com/btford/angular-express-seed) and uses the [Express](http://expressjs.com/) framework.

## Consuming JSONP APIs

### Problem
You want to call a JSONP API.

### Solution
Use the `$resource` and configure it to use JSONP. As an example we will call the Twitter search API here.

    <body ng-app="MyApp">
      <div ng-controller="MyCtrl">
        <input type="text" ng-model="searchTerm" placeholder="Search term">
        <button ng-click="search()">Search</button>
        <ul ng-repeat="tweet in searchResult.results">
          <li>{{tweet.text}}</li>
        </ul>
      </div>
    </body>

    var app = angular.module("MyApp", ["ngResource"]);

    function MyCtrl($scope, $resource) {
      $scope.twitterAPI = $resource("http://search.twitter.com/search.json",
        { callback: "JSON_CALLBACK" },
        { get: { method: "JSONP" }});

      $scope.search = function() {
        $scope.searchResult = $scope.twitterAPI.get({ q: $scope.searchTerm });
      };
    }

### Discussion
The `$resource` definition sets the `callback` attribute to `JSON_CALLBACK`, a requirement from Angular. Additionally we overwrite the get method to use `JSONP`. Now, when calling the API we use the `q` param to pass the entered `searchTerm`.

## Deferred and Promise
TODO: Write me!

## Testing Services

### Problem
You want to unit test your controller and service consuming a JSONP API.

Lets have a look again at our example we want to test:

    var app = angular.module("MyApp", ["ngResource"]);

    app.factory("TwitterAPI", function($resource) {
      return $resource("http://search.twitter.com/search.json",
        { callback: "JSON_CALLBACK" },
        { get: { method: "JSONP" }});
    });

    app.controller("MyCtrl", function($scope, TwitterAPI) {
      $scope.search = function() {
        $scope.searchResult = TwitterAPI.get({ q: $scope.searchTerm });
      };
    });

Note, that it slightly changed from the previous recipe as the `TwitterAPI` is pulled out of the controller and resides in its own service now.

### Solution
Use the angular-seed project and the $http_backend mocking service.

    describe('MyCtrl', function(){
      var scope, ctrl, httpBackend;

      beforeEach(module("MyApp"));

      beforeEach(inject(function($controller, $rootScope, TwitterAPI, $httpBackend) {
        httpBackend = $httpBackend;
        scope = $rootScope.$new();
        ctrl = $controller("MyCtrl", { $scope: scope, TwitterAPI: TwitterAPI });

        var mockData = { key: "test" };
        var url = "http://search.twitter.com/search.json?callback=JSON_CALLBACK&q=angularjs";
        httpBackend.whenJSONP(url).respond(mockData);
      }));

      it('should set searchResult on successful search', function() {
        scope.searchTerm = "angularjs";
        scope.search();
        httpBackend.flush();

        expect(scope.searchResult.key).toBe("test");
      });

    });

### Discussion
Since we now have a clear separation between the service and the controller, we can simply inject the `TwitterAPI` in our `beforeEach` function.

Mocking with the `$httpBackend` is done as a last step in `beforeEach`. When a JSONP request happens we respond with `mockData`. After the `search()` is triggered we `flush()` the `httpBackend` in order to return our `mockData`.

Have a look at the [ngMock.$httpBackend](http://docs.angularjs.org/api/ngMock.$httpBackend) module for more details.
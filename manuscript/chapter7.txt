# Using Forms

## Implementing a Basic Form

### Problem
You want to create a form to enter user details and capture this information in an Angular.js scope.

### Solution
Use the standard `form` tag and the `ng-model` Directive to implement a basic form:

    <body ng-app="MyApp">
      <div ng-controller="User">
        <form ng-submit="submit()" class="form-horizontal">
          <label>Firstname</label>
          <input type="text" ng-model="user.firstname"/>
          <label>Lastname</label>
          <input type="text" ng-model="user.lastname"/>
          <label>Age</label>
          <input type="text" ng-model="user.age"/>
          <button class="btn">Submit</button>
        </form>
      </div>
    </body>

And a controller to bind the form data to your user model:

    var app = angular.module("MyApp", []);

    app.controller("User", function($scope) {
      $scope.user = {};
      $scope.wasSubmitted = false;

      $scope.submit = function() {
        $scope.wasSubmitted = true;
      };
    });

### Discussion
The initial idea when using forms would be to implement them the traditional way by serializing the form data and submit it to the server. Instead we use `ng-model` to bind the form to our model, something we have been doing a lot already in previous recipes. The submit button state is reflected in our `wasSubmitted` scope variable, but no submit to the server was actually done. The default behaviour in Angular.js forms is to prevent the default action since we do not want to reload the whole page. We want to handle the submission in an application specific way. In fact there is even more going on in the background and we are going to look into the behaviour of the `form` or `ng-form` Directive in the next recipe.

## Validating a Form Model client-side

### Problem
You want to validate the form client-side using HTML5 form attributes.

### Solution
Angular.js works in tandem with HTML5 form attributes. Let us start with the same form but let us add some HTML5 attributes to make the input required:

    <form name="form" ng-submit="submit()" class="form-horizontal">
      <label>Firstname</label>
      <input name="firstname" type="text" ng-model="user.firstname" required/>
      <label>Lastname</label>
      <input type="text" ng-model="user.lastname" required/>
      <label>Age</label>
      <input type="text" ng-model="user.age"/>
      <br>
      <button class="btn">Submit</button>
    </form>

It is still the same form but this time we defined the name attribute on the form and the input for the firstname.

Let us add some more debug output:

    Firstname input valid: {{form.firstname.$valid}}
    <br>
    Firstname validation error: {{form.firstname.$error}}
    <br>
    Form valid: {{form.$valid}}
    <br>
    Form validation error: {{form.$error}}

### Discussion
When starting with a fresh empty form, you notice that Angular adds the css class `ng-pristine` and `ng-valid` to the form tag and each input tag. When editing the form the `ng-pristine` class will be removed from the changed input and also from the form tag. Instead it will be replaced by the `ng-dirty` class. Very useful because you can easily add new features to your app depending on these states.

In addition to these two css classes there are two more to look into. The `ng-valid` class will be added whenever an input is valid, otherwise the css class `ng-invalid` is added. Note, that the form tag also gets either a valid or invalid class depending on the inputs. To demonstrate this I've added the `required` HTML5 attribute. Initially, the firstname and lastname input fields are empty and therefore have the `ng-invalid` css class, whereas the age input field has the `ng-valid` class. Additionally, there's `ng-invalid-required` class alongside the `ng-invalid` for even more specificity.

Since we defined the `name` attribute on the form HTML element we can now access Angular's form controller via scope variables. In the debug output we can check the validity and specific error for each named form input and the form itself. Note, that this only works on the level of the form name attributes and not on the model scope. If you output the following expression `{{user.firstname.$error}}` it will not work.

Angular's Form Controller exposes `$valid`, `$invalid`, `$error`, `$pristine` and `$dirty` variables.

Let us use Angular's form integration to actually show validation errors.

## Displaying Form Validation Errors

### Problem
You want to show valiation errors to the user by marking the input field red and displaying an error message.

### Solution
We can use the `ng-show` Directive to show an error message if a form input is invalid and css classes to change the input background color depending on its state.

Let us start with the styling changes:

    <style type="text/css">
      input.ng-invalid.ng-dirty {
        background-color: red;
      }
      input.ng-valid.ng-dirty {
        background-color: green;
      }
    </style>

And here is a small part of the form with a error message for the input field:

    <label>Firstname</label>
    <input name="firstname" type="text" ng-model="user.firstname" required/>
    <p ng-show="form.firstname.$invalid && form.firstname.$dirty">Firstname is required</p>

### Discussion
The CSS classes ensure that we initially show the fresh form without any colors. When the user starts typing in a input for the first time, we change it to either green or red. That is a good example usage of the `ng-dirty` and `ng-invalid` css classes.

We use the same logic in the `ng-show directive to only show the error message when the user started typing for the first time.

## Only Enabling the Submit button if the Form is Valid
### Problem
### Solution
### Discussion

## Resetting a Form Model
### Problem
### Solution
### Discussion


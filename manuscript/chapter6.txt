# URLs, Routing and Partials
The [$location service](http://docs.angularjs.org/guide/dev_guide.services.$location) in Angular.js parses the current browser URL and makes it available to your application. Changes in either the browser address bar or the `$location` service will be kept in sync.

Depending on the configuration the `$location` service behaves differently and has different requirements for your application. We will first look into client-side routing with hashbang URLs since it is the default mode and later into the new HTML5 based routing.

## Client-Side Routing with Hashbang URLs

### Problem
You want the browser address bar reflect your apps page flow consistently.

### Solution
Use the `$routeProvider` and `$locationProvider` services to define your routes and the `ng-view` Directive as the placeholder for the partials which should be shown for a particular route definition.

The basic HTML uses the `ng-view` directive:

    <body>
      <h1>Routing Example</h1>
      <ng-view></ng-view>

      <script src="lib/angular/angular.js"></script>
      <script src="js/app.js"></script>
    </body>

The route configuration is implemented in `app.js` using the `config` method:

    var app = angular.module("MyApp", []).
      config(function($routeProvider, $locationProvider) {
        $locationProvider.hashPrefix('!');
        $routeProvider.
          when("/persons", { templateUrl: "partials/index.html" }).
          when("/persons/:id", { templateUrl: "partials/show.html", controller: "ShowCtrl" }).
          otherwise( { redirectTo: "/persons" });
    });

The partial `index.html`:

    <h3>Person List</h3>
    <div ng-controller="IndexCtrl">
      <table>
        <thead>
          <tr>
            <td>Name</td>
            <td>Actions</td>
          </tr>
        </thead>
        <tbody>
          <tr ng-repeat="person in persons">
            <td>{{person.name}}</td>
            <td><a href="#!persons/{{person.id}}">Details</a></td>
          </tr>
        </tbody>
      </table>
    </div>

And the partial `show.html`;

    <h3>{{person.name}} Details</h3>
    <p>Name: {{person.name}}</p>
    <p>Age: {{person.age}}</p>

    <a href="#!persons">Go back</a>

Our app is configured to render either the `index.html` or the `show.html` partial depending on the URL. The `index.html` shows a list of `persons` and the `show.html` shows more detailed information for a specific `person`.

This example is based on the Angular Seed Bootstrap again and will not work without starting the development server. The complete project is available on Github.

### Discussion
Let's give our app a try and open the `index.html`. The `otherwise` defined route redirects us from `index.html` to `index.html#!/persons`. This is the fallback in case other `when` conditions don't apply. Note, how the hashbang (#!) separates the `index.html` from the dynamic client-side part `/persons`.

The `/persons` route loads the `index.html` partial via HTTP Request (that is also the reason why it won't work without a development server). It shows a list of persons and therefore defines a `ng-controller` directive inside the template. Let us assume for now that the Controller implementation defines a `$scope.persons` somewhere. Now for each person we also render a link to show the details via `#!persons/{{person.id}}`.

The route definition for the person's details uses a placeholder `/persons/:id` which in our case resolves to for example `/persons/1`. The `show.html` partial and additionally a Controller are defined for this URL. The Controller will be scoped to the partial, which basically resembles our `index.html` template where we defined our own `ng-controller` Directive to achieve the same effect.

The `show.html` has a back link to `#!persons` which leads back to the `index.html` page.

Let us come back to the `ng-view` directive. It is automatically bound to the router definition. Therefore you can currently use only a single `ng-view` on your page. For example, you cannot use nested `ng-view`s to achieve user interaction patterns with a first- and second level navigation.

And lastly the HTTP request for the partials happens only once and is then cached via `$templateCache` service.

The hashbang based routing is client-side only and doesn't require server-side configuration. Let us look into the HTML5 based approach next.

## Using Regular URLs with the HTML5 History API

### Problem
You want nice looking URLs and can provide server-side support.

### Solution
We use the same example but use the [Express](http://expressjs.com/) framework to serve all content and do the URL rewriting. Let us start with the route configuration:

    app.config(function($routeProvider, $locationProvider) {
      $locationProvider.html5Mode(true);

      $routeProvider.
        when("/persons", { templateUrl: "/partials/index.jade", controller: "PersonIndexCtrl" }).
        when("/persons/:id", { templateUrl: "/partials/show.jade", controller: "PersonShowCtrl" }).
        otherwise( { redirectTo: "/persons" });
    });

There are no changes except the `html5Mode` method which enables our new routing mechanism. The Controller implementation does not change at all.

We have to take care of the partial loading. Our `Express` app will have to serve the partials for us:

    app.get('/partials/:name', function (req, res) {
      var name = req.params.name;
      res.render('partials/' + name);
    });

The `Express` route definition loads the partial with given name from the `partials` directory and renders its content.

When supporting HTML5 routing our server has to redirect all other URLs to the entry point of our application, the `index` page. First the rendering of the `index` page, which contains the `ng-view` Directive:

    app.get('/', function(req, res) {
      res.render('index');
    });

Then the catch all route which redirects to the same page:

    app.get('*', function(req, res) {
      res.redirect('/');
    });

The person details link `/persons/{{person.id}}` and the back link `/persons` are both now much cleaner.

Have a look at the complete example on Github and start the `Express` app with `node app.js`.

### Discussion
If we wouldn't redirect all requests to the root, what would happen if you navigate to the persons list at `http://localhost:3000/persons`? The `Express` framework would show us an error because there is no route defined for `persons`, we only defined routes for our root `/` and the partials URL `/partials/:name`. The redirect ensures that we actually end up at our root URL which then kicks in our Angular app. When the client-side routing takes over we actually then redirect back to the `/persons` URL.

Also note how navigating to a Person's detail page will load only the `show.jade` partial and navigating back to the `persons` list won't do any server requests. Everything our app needs is loaded from the server and cached client-side.

If you have a hard time understanding the server implementation I suggest to read the excellent [Express Guide](http://expressjs.com/guide.html). Additionally, there is going to be an extra chapter which goes into more details on how to integrate Angular.js with server-side frameworks.

## Using route location to implement a navigation menu

### Problem
You want to implement a navigation menu which shows the selected menu item to the user.

### Solution
Use the `$location` service in a controller to compare the address bar URL to the navigation menu item the user selected.

The navigation menu is the classic ul/li menu using a class attribute to mark one of the `li` elements as `active`:

    <body ng-controller="MainCtrl">
      <ul class="menu">
        <li ng-class="menuClass('persons')"><a href="#!persons">Home</a></li>
        <li ng-class="menuClass('help')"><a href="#!help">Help</a></li>
      </ul>
      ...
    </body>


The controller implements the `menuClass` function:

    app.controller("MainCtrl", function($scope, $location) {
      $scope.menuClass = function(page) {
        var current = $location.path().substring(1);
        return page === current ? "active" : "";
      };
    });

### Discussion
When the user selects a menu item the client-side navigation will kick in as expected. The `menuClass` function is a bind using the `ngClass` directive and updates the CSS class automatically for us depending on the current route.

Using `$location.path()` we get the current route. The `substring` operation removes the leading `/` and converts `/persons` to `persons` only.

## Listening on route changes to implement a login mechanism

### Problem
You want to ensure that a user first has to login before navigating to protected pages.

### Solution
Implement a listener on `$routeChangeStart` events to track the next route navigation. Redirect to a login page if the user is not logged in yet.

The most interesting part is the listener:

    var app = angular.module("MyApp", []).
      config(function($routeProvider, $locationProvider) {
        $routeProvider.
          when("/persons", { templateUrl: "partials/index.html" }).
          when("/login", { templateUrl: "partials/login.html", controller: "LoginCtrl" }).
          // event more routes here ...
          otherwise( { redirectTo: "/persons" });
      }).
      run(function($rootScope, $location) {

        $rootScope.$on( "$routeChangeStart", function(event, next, current) {
          if ($rootScope.loggedInUser == null) {
            // no logged user, redirect to /login
            if ( next.templateUrl === "partials/login.html") {
            } else {
              $location.path("/login");
            }
          }
        });
      });

Next we need the login controller which sets the logged in user and redirects.

    app.controller("LoginCtrl", function($scope, $location, $rootScope) {
      $scope.login = function() {
        $rootScope.loggedInUser = $scope.username;
        $location.path("/persons");
      };
    });

and lastly the login form:

    <form ng-submit="login()">
      <label>Username</label>
      <input type="text" ng-model="username">
      <button>Login</button>
    </form>

### Discussion
This is of course not a full fletched login system, so please don't use it in any production system. But, it exemplifies how to generally handle access to specific areas of your web app. When you open the app in your browser you will be redirected to the login app in all cases. Only after you entered a user you can access the other areas.

The `run` method is defined in [Module](http://docs.angularjs.org/api/angular.Module) and is a good place for such a route change listener since it runs only once on initialization after the injector is done loading all the modules. We check the `loggedInUser` in the `$rootScope` and if it is not set we redirect the user to the login page. Note, that in order to skip this behaviour when already navigating to the login page, we have to explicitly check the next `templateUrl`.

The login controller sets the `$rootScope` to the username and redirects. Note, that we can easily access the `$rootScope` by injecting it.
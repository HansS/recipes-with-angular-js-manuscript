# URLs, Routing and Partials
The [$location service](http://docs.angularjs.org/guide/dev_guide.services.$location) in Angular.js parses the current browser URL and makes it available to your application. Changes in either the browser address bar or the `$location` service will be kept in sync.

Depending on the configuration the `$location` service behaves differently and has different requirements for your application. We will first look into client-side routing with hashbang URLs since it is the default mode and later into the new HTML5 based routing.

## Client-Side Routing with Hashbang URLs

### Problem
You want the browser address bar reflect your apps page flow consistently.

### Solution
Use the `$routeProvider` and `$locationProvider` services to define your routes and the `ng-view` Directive as the placeholder for the partials which should be shown for a particular route definition.

The basic HTML uses the `ng-view` directive:

    <body>
      <h1>Routing Example</h1>
      <ng-view></ng-view>

      <script src="lib/angular/angular.js"></script>
      <script src="js/app.js"></script>
    </body>

The route configuration is implemented in `app.js` using the `config` method:

    var app = angular.module("MyApp", []).
      config(function($routeProvider, $locationProvider) {
        $locationProvider.hashPrefix('!');
        $routeProvider.
          when("/persons", { templateUrl: "partials/index.html" }).
          when("/persons/:id", { templateUrl: "partials/show.html", controller: "ShowCtrl" }).
          otherwise( { redirectTo: "/persons" });
    });

The partial `index.html`:

    <h3>Person List</h3>
    <div ng-controller="IndexCtrl">
      <table>
        <thead>
          <tr>
            <td>Name</td>
            <td>Actions</td>
          </tr>
        </thead>
        <tbody>
          <tr ng-repeat="person in persons">
            <td>{{person.name}}</td>
            <td><a href="#!persons/{{person.id}}">Details</a></td>
          </tr>
        </tbody>
      </table>
    </div>

And the partial `show.html`;

    <h3>{{person.name}} Details</h3>
    <p>Name: {{person.name}}</p>
    <p>Age: {{person.age}}</p>

    <a href="#!persons">Go back</a>

Our app is configured to render either the `index.html` or the `show.html` partial depending on the URL. The `index.html` shows a list of `persons` and the `show.html` shows more detailed information for a specific `person`.

This example is based on the Angular Seed Bootstrap again and will not work without starting the development server. The complete project is available on Github.

### Discussion
Let's give our app a try and open the `index.html`. The `otherwise` defined route redirects us from `index.html` to `index.html#!/persons`. This is the fallback in case other `when` conditions don't apply. Note, how the hashbang (#!) separates the `index.html` from the dynamic client-side part `/persons`.

The `/persons` route loads the `index.html` partial via HTTP Request (that is also the reason why it won't work without a development server). It shows a list of persons and therefore defines a `ng-controller` directive inside the template. Let us assume for now that the Controller implementation defines a `$scope.persons` somewhere. Now for each person we also render a link to show the details via `#!persons/{{person.id}}`.

The route definition for the person's details uses a placeholder `/persons/:id` which in our case resolves to for example `/persons/1`. The `show.html` partial and additionally a Controller are defined for this URL. The Controller will be scoped to the partial, which basically resembles our `index.html` template where we defined our own `ng-controller` Directive to achieve the same effect.

The `show.html` has a back link to `#!persons` which leads back to the `index.html` page.

Let us come back to the `ng-view` directive. It is automatically bound to the router definition. Therefore you can currently use only a single `ng-view` on your page. For example, you cannot use nested `ng-view`s to achieve user interaction patterns with a first- and second level navigation.

And lastly the HTTP request for the partials happens only once and is then cached via `$templateCache` service.

The hashbang based routing is client-side only and doesn't require server-side configuration. Let us look into the HTML5 based approach next.

## Using Regular URLs with the HTML5 History API

### Problem
You want nice looking URLs and can provide server-side support.

### Solution
We use the same example but use the [Express](http://expressjs.com/) framework to serve all content and do the URL rewriting. Let us start with the route configuration:

    app.config(function($routeProvider, $locationProvider) {
      $locationProvider.html5Mode(true);

      $routeProvider.
        when("/persons", { templateUrl: "/partials/index.jade", controller: "PersonIndexCtrl" }).
        when("/persons/:id", { templateUrl: "/partials/show.jade", controller: "PersonShowCtrl" }).
        otherwise( { redirectTo: "/persons" });
    });

There are no changes except the `html5Mode` method which enables our new routing mechanism. The Controller implementation does not change at all.

We have to take care of the partial loading. Our `Express` app will have to serve the partials for us:

    app.get('/partials/:name', function (req, res) {
      var name = req.params.name;
      res.render('partials/' + name);
    });

The `Express` route definition loads the partial with given name from the `partials` directory and renders its content.

When supporting HTML5 routing our server has to redirect all other URLs to the entry point of our application, the `index` page. First the rendering of the `index` page, which contains the `ng-view` Directive:

    app.get('/', function(req, res) {
      res.render('index');
    });

Then the catch all route which redirects to the same page:

    app.get('*', function(req, res) {
      res.redirect('/');
    });

The person details link `/persons/{{person.id}}` and the back link `/persons` are both now much cleaner.

Have a look at the complete example on Github and start the `Express` app with `node app.js`.

### Discussion
If we wouldn't redirect all requests to the root, what would happen if you navigate to the persons list at `http://localhost:3000/persons`? The `Express` framework would show us an error because there is no route defined for `persons`, we only defined routes for our root `/` and the partials URL `/partials/:name`. The redirect ensures that we actually end up at our root URL which then kicks in our Angular app. When the client-side routing takes over we actually then redirect back to the `/persons` URL.

Also note how navigating to a Person's detail page will load only the `show.jade` partial and navigating back to the `persons` list won't do any server requests. Everything our app needs is loaded from the server and cached client-side.

If you have a hard time understanding the server implementation I suggest to read the excellent [Express Guide](http://expressjs.com/guide.html). Additionally, there is going to be an extra chapter which goes into more details on how to integrate Angular.js with server-side frameworks.
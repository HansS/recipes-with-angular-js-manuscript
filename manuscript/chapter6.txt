# URLs, Routing and Partials
The `$location` [service](http://docs.angularjs.org/guide/dev_guide.services.$location) in Angular.js parses the current browser URL and makes it available to your application.

Depending on the configuration the `$location` service behaves differently and has different requirements for your application. We will first look into client-side routing with hashbang URLs since it is the default mode and later in using the new HTML5 based routing.

## Client-Side Routing with Hashbang URLs

### Problem
You want to the browser address bar reflect your apps page flow consistently.

### Solution
Use the `$routeProvider` and `$locationProvider` services to define your routes.

The basic HTML uses the `ng-view` directive;

    <body>
      <h1>Routing Example</h1>
      <ng-view></ng-view>
      <script src="lib/angular/angular.js"></script>
      <script src="js/app.js"></script>
    </body>

Next we need to define the route configuration in `app.js`;

    var app = angular.module("MyApp", []).
      config(function($routeProvider, $locationProvider) {
        $locationProvider.hashPrefix('!');
        $routeProvider.
          when("/persons", { templateUrl: "partials/index.html" }).
          when("/persons/:id", { templateUrl: "partials/show.html", controller: "ShowCtrl" }).
          otherwise( { redirectTo: "/persons" });
    });

The partial `index.html`:

    <h3>Person List</h3>
    <div ng-controller="IndexCtrl">
      <table>
        <thead>
          <tr>
            <td>Name</td>
            <td>Actions</td>
          </tr>
        </thead>
        <tbody>
          <tr ng-repeat="person in persons">
            <td>{{person.name}}</td>
            <td><a href="#!persons/{{person.id}}">Details</a></td>
          </tr>
        </tbody>
      </table>
    </div>

And the partial `show.html`;

    <h3>{{person.name}} Details</h3>
    <p>Name: {{person.name}}</p>
    <p>Age: {{person.age}}</p>

    <a href="#!persons">Go back</a>

It is configured to render either the `index.html` or the `show.html` partial depending on the URL. The `index.html` shows a list of `persons` and the `show.html` shows more detailed information for a specific `person`.

This example is based on the Angular Seed Bootstrap again and will not work without starting the development server. The complete project is available on Github.

### Discussion
Let's give our app a try and open the `index.html`. Note, how the `otherwise` defined route redirects us from `index.html` to `index.html#!/persons`. This is the fallback in case other `when` conditions don't apply. Note, how the hashbang (#!) separates the `index.html` from the dynamic client-side part `/persons`.

The `/persons` route loads the `index.html` partial via HTTP Request (that is also the reason why it won't work without a development server). It shows a list of persons and therefore defines a `ng-controller` directive inside the template. Let us assume for now that the Controller implementation defines a `$scope.persons` somewhere. Now for each person we also render a link to show the details via `#!persons/{{person.id}}`.

The route definition for the details uses a placeholder `/persons/:id` which will be in our case resolves to for example `/persons/1`. The `show.html` partial and additionally a Controller are defined for this URL. The Controller will be scoped to the partial, which basically resembles our `index.html` template where we defined our own `ng-controller` Directive to achieve the same effect.

The `show.html` has a back link to `#!persons` which leads back to the `index.html` page.

Let us come back to the `ng-view` directive. It is automatically bound to the router definition. Therefore you can currently use only a single `ng-view` on your page. For example, you cannot use nested `ng-view`s to achieve user interaction patterns with a first- and second level navigation. We will look into this particular problem in a later recipe.

And lastly the HTTP request for the partials happens only once and is then cached via `$templateCache` service.

The hashbang based routing is client-side only and doesn't require server-side configuration. Let us look into the HTML5 based approach next.

## Using Regular URLs with the HTML5 History API

### Problem
You only support more recent browsers

### Solution
### Discussion
